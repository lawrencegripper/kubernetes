package batchservice

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator 1.0.1.0
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.

import (
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"net/http"
)

// FileClient is the a client for issuing REST requests to the Azure Batch
// service.
type FileClient struct {
	ManagementClient
}

// NewFileClient creates an instance of the FileClient client.
func NewFileClient() FileClient {
	return NewFileClientWithBaseURI(DefaultBaseURI)
}

// NewFileClientWithBaseURI creates an instance of the FileClient client.
func NewFileClientWithBaseURI(baseURI string) FileClient {
	return FileClient{NewWithBaseURI(baseURI)}
}

// DeleteFromComputeNode deletes the specified task file from the compute node.
//
// poolID is the id of the pool that contains the compute node. nodeID is the
// id of the compute node from which you want to delete the file. fileName is
// the path to the file that you want to delete. recursive is sets whether to
// delete children of a directory. If the fileName parameter represents a
// directory instead of a file, you can set Recursive to true to delete the
// directory and all of the files and subdirectories in it. If Recursive is
// false then the directory must be empty or deletion will fail. timeout is
// sets the maximum time that the server can spend processing the request, in
// seconds. The default is 30 seconds. clientRequestID is caller generated
// request identity, in the form of a GUID with no decoration such as curly
// braces e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. returnClientRequestID is
// specifies if the server should return the client-request-id identifier in
// the response. ocpDate is the time the request was issued. If not specified,
// this header will be automatically populated with the current system clock
// time.
func (client FileClient) DeleteFromComputeNode(poolID string, nodeID string, fileName string, recursive *bool, timeout *int32, clientRequestID string, returnClientRequestID *bool, ocpDate *date.TimeRFC1123) (result autorest.Response, err error) {
	req, err := client.DeleteFromComputeNodePreparer(poolID, nodeID, fileName, recursive, timeout, clientRequestID, returnClientRequestID, ocpDate)
	if err != nil {
		err = autorest.NewErrorWithError(err, "batchservice.FileClient", "DeleteFromComputeNode", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteFromComputeNodeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "batchservice.FileClient", "DeleteFromComputeNode", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteFromComputeNodeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "batchservice.FileClient", "DeleteFromComputeNode", resp, "Failure responding to request")
	}

	return
}

// DeleteFromComputeNodePreparer prepares the DeleteFromComputeNode request.
func (client FileClient) DeleteFromComputeNodePreparer(poolID string, nodeID string, fileName string, recursive *bool, timeout *int32, clientRequestID string, returnClientRequestID *bool, ocpDate *date.TimeRFC1123) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"fileName": autorest.Encode("path", fileName),
		"nodeId":   autorest.Encode("path", nodeID),
		"poolId":   autorest.Encode("path", poolID),
	}

	const APIVersion = "2015-12-01.2.2"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if recursive != nil {
		queryParameters["recursive"] = autorest.Encode("query", *recursive)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/pools/{poolId}/nodes/{nodeId}/files/{fileName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if len(clientRequestID) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("client-request-id", autorest.String(clientRequestID)))
	}
	if returnClientRequestID != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("return-client-request-id", autorest.String(returnClientRequestID)))
	}
	if ocpDate != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("ocp-date", autorest.String(ocpDate)))
	}
	return preparer.Prepare(&http.Request{})
}

// DeleteFromComputeNodeSender sends the DeleteFromComputeNode request. The method will close the
// http.Response Body if it receives an error.
func (client FileClient) DeleteFromComputeNodeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// DeleteFromComputeNodeResponder handles the response to the DeleteFromComputeNode request. The method always
// closes the http.Response Body.
func (client FileClient) DeleteFromComputeNodeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteFromTask deletes the specified task file from the compute node where
// the task ran.
//
// jobID is the id of the job that contains the task. taskID is the id of the
// task whose file you want to delete. fileName is the path to the task file
// that you want to delete. recursive is sets whether to delete children of a
// directory. If the fileName parameter represents a directory instead of a
// file, you can set Recursive to true to delete the directory and all of the
// files and subdirectories in it. If Recursive is false then the directory
// must be empty or deletion will fail. timeout is sets the maximum time that
// the server can spend processing the request, in seconds. The default is 30
// seconds. clientRequestID is caller generated request identity, in the form
// of a GUID with no decoration such as curly braces e.g.
// 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. returnClientRequestID is specifies if
// the server should return the client-request-id identifier in the response.
// ocpDate is the time the request was issued. If not specified, this header
// will be automatically populated with the current system clock time.
func (client FileClient) DeleteFromTask(jobID string, taskID string, fileName string, recursive *bool, timeout *int32, clientRequestID string, returnClientRequestID *bool, ocpDate *date.TimeRFC1123) (result autorest.Response, err error) {
	req, err := client.DeleteFromTaskPreparer(jobID, taskID, fileName, recursive, timeout, clientRequestID, returnClientRequestID, ocpDate)
	if err != nil {
		err = autorest.NewErrorWithError(err, "batchservice.FileClient", "DeleteFromTask", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteFromTaskSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "batchservice.FileClient", "DeleteFromTask", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteFromTaskResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "batchservice.FileClient", "DeleteFromTask", resp, "Failure responding to request")
	}

	return
}

// DeleteFromTaskPreparer prepares the DeleteFromTask request.
func (client FileClient) DeleteFromTaskPreparer(jobID string, taskID string, fileName string, recursive *bool, timeout *int32, clientRequestID string, returnClientRequestID *bool, ocpDate *date.TimeRFC1123) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"fileName": autorest.Encode("path", fileName),
		"jobId":    autorest.Encode("path", jobID),
		"taskId":   autorest.Encode("path", taskID),
	}

	const APIVersion = "2015-12-01.2.2"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if recursive != nil {
		queryParameters["recursive"] = autorest.Encode("query", *recursive)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/jobs/{jobId}/tasks/{taskId}/files/{fileName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if len(clientRequestID) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("client-request-id", autorest.String(clientRequestID)))
	}
	if returnClientRequestID != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("return-client-request-id", autorest.String(returnClientRequestID)))
	}
	if ocpDate != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("ocp-date", autorest.String(ocpDate)))
	}
	return preparer.Prepare(&http.Request{})
}

// DeleteFromTaskSender sends the DeleteFromTask request. The method will close the
// http.Response Body if it receives an error.
func (client FileClient) DeleteFromTaskSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// DeleteFromTaskResponder handles the response to the DeleteFromTask request. The method always
// closes the http.Response Body.
func (client FileClient) DeleteFromTaskResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// GetFromComputeNode gets the content of the specified task file.
//
// poolID is the id of the pool that contains the compute node. nodeID is the
// id of the compute node that contains the file. fileName is the path to the
// task file that you want to get the content of. timeout is sets the maximum
// time that the server can spend processing the request, in seconds. The
// default is 30 seconds. clientRequestID is caller generated request identity,
// in the form of a GUID with no decoration such as curly braces e.g.
// 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. returnClientRequestID is specifies if
// the server should return the client-request-id identifier in the response.
// ocpDate is the time the request was issued. If not specified, this header
// will be automatically populated with the current system clock time. ocpRange
// is specifies the byte range to be retrieved. The default is to retrieve the
// entire file.  The format is startRange-endRange. ifModifiedSince is specify
// this header to perform the operation only if the resource has been modified
// since the specified date/time. ifUnmodifiedSince is specify this header to
// perform the operation only if the resource has not been modified since the
// specified date/time.
func (client FileClient) GetFromComputeNode(poolID string, nodeID string, fileName string, timeout *int32, clientRequestID string, returnClientRequestID *bool, ocpDate *date.TimeRFC1123, ocpRange string, ifModifiedSince *date.TimeRFC1123, ifUnmodifiedSince *date.TimeRFC1123) (result ReadCloser, err error) {
	req, err := client.GetFromComputeNodePreparer(poolID, nodeID, fileName, timeout, clientRequestID, returnClientRequestID, ocpDate, ocpRange, ifModifiedSince, ifUnmodifiedSince)
	if err != nil {
		err = autorest.NewErrorWithError(err, "batchservice.FileClient", "GetFromComputeNode", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetFromComputeNodeSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "batchservice.FileClient", "GetFromComputeNode", resp, "Failure sending request")
		return
	}

	result, err = client.GetFromComputeNodeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "batchservice.FileClient", "GetFromComputeNode", resp, "Failure responding to request")
	}

	return
}

// GetFromComputeNodePreparer prepares the GetFromComputeNode request.
func (client FileClient) GetFromComputeNodePreparer(poolID string, nodeID string, fileName string, timeout *int32, clientRequestID string, returnClientRequestID *bool, ocpDate *date.TimeRFC1123, ocpRange string, ifModifiedSince *date.TimeRFC1123, ifUnmodifiedSince *date.TimeRFC1123) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"fileName": autorest.Encode("path", fileName),
		"nodeId":   autorest.Encode("path", nodeID),
		"poolId":   autorest.Encode("path", poolID),
	}

	const APIVersion = "2015-12-01.2.2"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/pools/{poolId}/nodes/{nodeId}/files/{fileName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if len(clientRequestID) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("client-request-id", autorest.String(clientRequestID)))
	}
	if returnClientRequestID != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("return-client-request-id", autorest.String(returnClientRequestID)))
	}
	if ocpDate != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("ocp-date", autorest.String(ocpDate)))
	}
	if len(ocpRange) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("ocp-range", autorest.String(ocpRange)))
	}
	if ifModifiedSince != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("If-Modified-Since", autorest.String(ifModifiedSince)))
	}
	if ifUnmodifiedSince != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("If-Unmodified-Since", autorest.String(ifUnmodifiedSince)))
	}
	return preparer.Prepare(&http.Request{})
}

// GetFromComputeNodeSender sends the GetFromComputeNode request. The method will close the
// http.Response Body if it receives an error.
func (client FileClient) GetFromComputeNodeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetFromComputeNodeResponder handles the response to the GetFromComputeNode request. The method always
// closes the http.Response Body.
func (client FileClient) GetFromComputeNodeResponder(resp *http.Response) (result ReadCloser, err error) {
	result.Value = &resp.Body
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK))
	result.Response = autorest.Response{Response: resp}
	return
}

// GetFromTask gets the content of the specified task file.
//
// jobID is the id of the job that contains the task. taskID is the id of the
// task whose file you want to retrieve. fileName is the path to the task file
// that you want to get the content of. timeout is sets the maximum time that
// the server can spend processing the request, in seconds. The default is 30
// seconds. clientRequestID is caller generated request identity, in the form
// of a GUID with no decoration such as curly braces e.g.
// 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. returnClientRequestID is specifies if
// the server should return the client-request-id identifier in the response.
// ocpDate is the time the request was issued. If not specified, this header
// will be automatically populated with the current system clock time. ocpRange
// is specifies the byte range to be retrieved. The default is to retrieve the
// entire file.  The format is startRange-endRange. ifModifiedSince is specify
// this header to perform the operation only if the resource has been modified
// since the specified date/time. ifUnmodifiedSince is specify this header to
// perform the operation only if the resource has not been modified since the
// specified date/time.
func (client FileClient) GetFromTask(jobID string, taskID string, fileName string, timeout *int32, clientRequestID string, returnClientRequestID *bool, ocpDate *date.TimeRFC1123, ocpRange string, ifModifiedSince *date.TimeRFC1123, ifUnmodifiedSince *date.TimeRFC1123) (result ReadCloser, err error) {
	req, err := client.GetFromTaskPreparer(jobID, taskID, fileName, timeout, clientRequestID, returnClientRequestID, ocpDate, ocpRange, ifModifiedSince, ifUnmodifiedSince)
	if err != nil {
		err = autorest.NewErrorWithError(err, "batchservice.FileClient", "GetFromTask", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetFromTaskSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "batchservice.FileClient", "GetFromTask", resp, "Failure sending request")
		return
	}

	result, err = client.GetFromTaskResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "batchservice.FileClient", "GetFromTask", resp, "Failure responding to request")
	}

	return
}

// GetFromTaskPreparer prepares the GetFromTask request.
func (client FileClient) GetFromTaskPreparer(jobID string, taskID string, fileName string, timeout *int32, clientRequestID string, returnClientRequestID *bool, ocpDate *date.TimeRFC1123, ocpRange string, ifModifiedSince *date.TimeRFC1123, ifUnmodifiedSince *date.TimeRFC1123) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"fileName": autorest.Encode("path", fileName),
		"jobId":    autorest.Encode("path", jobID),
		"taskId":   autorest.Encode("path", taskID),
	}

	const APIVersion = "2015-12-01.2.2"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/jobs/{jobId}/tasks/{taskId}/files/{fileName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if len(clientRequestID) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("client-request-id", autorest.String(clientRequestID)))
	}
	if returnClientRequestID != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("return-client-request-id", autorest.String(returnClientRequestID)))
	}
	if ocpDate != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("ocp-date", autorest.String(ocpDate)))
	}
	if len(ocpRange) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("ocp-range", autorest.String(ocpRange)))
	}
	if ifModifiedSince != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("If-Modified-Since", autorest.String(ifModifiedSince)))
	}
	if ifUnmodifiedSince != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("If-Unmodified-Since", autorest.String(ifUnmodifiedSince)))
	}
	return preparer.Prepare(&http.Request{})
}

// GetFromTaskSender sends the GetFromTask request. The method will close the
// http.Response Body if it receives an error.
func (client FileClient) GetFromTaskSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetFromTaskResponder handles the response to the GetFromTask request. The method always
// closes the http.Response Body.
func (client FileClient) GetFromTaskResponder(resp *http.Response) (result ReadCloser, err error) {
	result.Value = &resp.Body
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK))
	result.Response = autorest.Response{Response: resp}
	return
}

// GetNodeFilePropertiesFromComputeNode gets the properties of the specified
// compute node file.
//
// poolID is the id of the pool that contains the compute node. nodeID is the
// id of the compute node that contains the file. fileName is the path to the
// compute node file that you want to get the properties of. timeout is sets
// the maximum time that the server can spend processing the request, in
// seconds. The default is 30 seconds. clientRequestID is caller generated
// request identity, in the form of a GUID with no decoration such as curly
// braces e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. returnClientRequestID is
// specifies if the server should return the client-request-id identifier in
// the response. ocpDate is the time the request was issued. If not specified,
// this header will be automatically populated with the current system clock
// time. ifModifiedSince is specify this header to perform the operation only
// if the resource has been modified since the specified date/time.
// ifUnmodifiedSince is specify this header to perform the operation only if
// the resource has not been modified since the specified date/time.
func (client FileClient) GetNodeFilePropertiesFromComputeNode(poolID string, nodeID string, fileName string, timeout *int32, clientRequestID string, returnClientRequestID *bool, ocpDate *date.TimeRFC1123, ifModifiedSince *date.TimeRFC1123, ifUnmodifiedSince *date.TimeRFC1123) (result autorest.Response, err error) {
	req, err := client.GetNodeFilePropertiesFromComputeNodePreparer(poolID, nodeID, fileName, timeout, clientRequestID, returnClientRequestID, ocpDate, ifModifiedSince, ifUnmodifiedSince)
	if err != nil {
		err = autorest.NewErrorWithError(err, "batchservice.FileClient", "GetNodeFilePropertiesFromComputeNode", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetNodeFilePropertiesFromComputeNodeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "batchservice.FileClient", "GetNodeFilePropertiesFromComputeNode", resp, "Failure sending request")
		return
	}

	result, err = client.GetNodeFilePropertiesFromComputeNodeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "batchservice.FileClient", "GetNodeFilePropertiesFromComputeNode", resp, "Failure responding to request")
	}

	return
}

// GetNodeFilePropertiesFromComputeNodePreparer prepares the GetNodeFilePropertiesFromComputeNode request.
func (client FileClient) GetNodeFilePropertiesFromComputeNodePreparer(poolID string, nodeID string, fileName string, timeout *int32, clientRequestID string, returnClientRequestID *bool, ocpDate *date.TimeRFC1123, ifModifiedSince *date.TimeRFC1123, ifUnmodifiedSince *date.TimeRFC1123) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"fileName": autorest.Encode("path", fileName),
		"nodeId":   autorest.Encode("path", nodeID),
		"poolId":   autorest.Encode("path", poolID),
	}

	const APIVersion = "2015-12-01.2.2"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsHead(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/pools/{poolId}/nodes/{nodeId}/files/{fileName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if len(clientRequestID) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("client-request-id", autorest.String(clientRequestID)))
	}
	if returnClientRequestID != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("return-client-request-id", autorest.String(returnClientRequestID)))
	}
	if ocpDate != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("ocp-date", autorest.String(ocpDate)))
	}
	if ifModifiedSince != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("If-Modified-Since", autorest.String(ifModifiedSince)))
	}
	if ifUnmodifiedSince != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("If-Unmodified-Since", autorest.String(ifUnmodifiedSince)))
	}
	return preparer.Prepare(&http.Request{})
}

// GetNodeFilePropertiesFromComputeNodeSender sends the GetNodeFilePropertiesFromComputeNode request. The method will close the
// http.Response Body if it receives an error.
func (client FileClient) GetNodeFilePropertiesFromComputeNodeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetNodeFilePropertiesFromComputeNodeResponder handles the response to the GetNodeFilePropertiesFromComputeNode request. The method always
// closes the http.Response Body.
func (client FileClient) GetNodeFilePropertiesFromComputeNodeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// GetNodeFilePropertiesFromTask gets the properties of the specified task
// file.
//
// jobID is the id of the job that contains the task. taskID is the id of the
// task whose file you want to get the properties of. fileName is the path to
// the task file that you want to get the properties of. timeout is sets the
// maximum time that the server can spend processing the request, in seconds.
// The default is 30 seconds. clientRequestID is caller generated request
// identity, in the form of a GUID with no decoration such as curly braces e.g.
// 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. returnClientRequestID is specifies if
// the server should return the client-request-id identifier in the response.
// ocpDate is the time the request was issued. If not specified, this header
// will be automatically populated with the current system clock time.
// ifModifiedSince is specify this header to perform the operation only if the
// resource has been modified since the specified date/time. ifUnmodifiedSince
// is specify this header to perform the operation only if the resource has not
// been modified since the specified date/time.
func (client FileClient) GetNodeFilePropertiesFromTask(jobID string, taskID string, fileName string, timeout *int32, clientRequestID string, returnClientRequestID *bool, ocpDate *date.TimeRFC1123, ifModifiedSince *date.TimeRFC1123, ifUnmodifiedSince *date.TimeRFC1123) (result autorest.Response, err error) {
	req, err := client.GetNodeFilePropertiesFromTaskPreparer(jobID, taskID, fileName, timeout, clientRequestID, returnClientRequestID, ocpDate, ifModifiedSince, ifUnmodifiedSince)
	if err != nil {
		err = autorest.NewErrorWithError(err, "batchservice.FileClient", "GetNodeFilePropertiesFromTask", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetNodeFilePropertiesFromTaskSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "batchservice.FileClient", "GetNodeFilePropertiesFromTask", resp, "Failure sending request")
		return
	}

	result, err = client.GetNodeFilePropertiesFromTaskResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "batchservice.FileClient", "GetNodeFilePropertiesFromTask", resp, "Failure responding to request")
	}

	return
}

// GetNodeFilePropertiesFromTaskPreparer prepares the GetNodeFilePropertiesFromTask request.
func (client FileClient) GetNodeFilePropertiesFromTaskPreparer(jobID string, taskID string, fileName string, timeout *int32, clientRequestID string, returnClientRequestID *bool, ocpDate *date.TimeRFC1123, ifModifiedSince *date.TimeRFC1123, ifUnmodifiedSince *date.TimeRFC1123) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"fileName": autorest.Encode("path", fileName),
		"jobId":    autorest.Encode("path", jobID),
		"taskId":   autorest.Encode("path", taskID),
	}

	const APIVersion = "2015-12-01.2.2"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsHead(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/jobs/{jobId}/tasks/{taskId}/files/{fileName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if len(clientRequestID) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("client-request-id", autorest.String(clientRequestID)))
	}
	if returnClientRequestID != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("return-client-request-id", autorest.String(returnClientRequestID)))
	}
	if ocpDate != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("ocp-date", autorest.String(ocpDate)))
	}
	if ifModifiedSince != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("If-Modified-Since", autorest.String(ifModifiedSince)))
	}
	if ifUnmodifiedSince != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("If-Unmodified-Since", autorest.String(ifUnmodifiedSince)))
	}
	return preparer.Prepare(&http.Request{})
}

// GetNodeFilePropertiesFromTaskSender sends the GetNodeFilePropertiesFromTask request. The method will close the
// http.Response Body if it receives an error.
func (client FileClient) GetNodeFilePropertiesFromTaskSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetNodeFilePropertiesFromTaskResponder handles the response to the GetNodeFilePropertiesFromTask request. The method always
// closes the http.Response Body.
func (client FileClient) GetNodeFilePropertiesFromTaskResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ListFromComputeNode lists all of the files in task directories on the
// specified compute node.
//
// poolID is the id of the pool that contains the compute node. nodeID is the
// id of the compute node whose files you want to list. filter is sets an OData
// $filter clause. recursive is sets whether to list children of a directory.
// maxResults is sets the maximum number of items to return in the response.
// timeout is sets the maximum time that the server can spend processing the
// request, in seconds. The default is 30 seconds. clientRequestID is caller
// generated request identity, in the form of a GUID with no decoration such as
// curly braces e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
// returnClientRequestID is specifies if the server should return the
// client-request-id identifier in the response. ocpDate is the time the
// request was issued. If not specified, this header will be automatically
// populated with the current system clock time.
func (client FileClient) ListFromComputeNode(poolID string, nodeID string, filter string, recursive *bool, maxResults *int32, timeout *int32, clientRequestID string, returnClientRequestID *bool, ocpDate *date.TimeRFC1123) (result NodeFileListResult, err error) {
	req, err := client.ListFromComputeNodePreparer(poolID, nodeID, filter, recursive, maxResults, timeout, clientRequestID, returnClientRequestID, ocpDate)
	if err != nil {
		err = autorest.NewErrorWithError(err, "batchservice.FileClient", "ListFromComputeNode", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListFromComputeNodeSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "batchservice.FileClient", "ListFromComputeNode", resp, "Failure sending request")
		return
	}

	result, err = client.ListFromComputeNodeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "batchservice.FileClient", "ListFromComputeNode", resp, "Failure responding to request")
	}

	return
}

// ListFromComputeNodePreparer prepares the ListFromComputeNode request.
func (client FileClient) ListFromComputeNodePreparer(poolID string, nodeID string, filter string, recursive *bool, maxResults *int32, timeout *int32, clientRequestID string, returnClientRequestID *bool, ocpDate *date.TimeRFC1123) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeId": autorest.Encode("path", nodeID),
		"poolId": autorest.Encode("path", poolID),
	}

	const APIVersion = "2015-12-01.2.2"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = autorest.Encode("query", filter)
	}
	if recursive != nil {
		queryParameters["recursive"] = autorest.Encode("query", *recursive)
	}
	if maxResults != nil {
		queryParameters["maxresults"] = autorest.Encode("query", *maxResults)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/pools/{poolId}/nodes/{nodeId}/files", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if len(clientRequestID) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("client-request-id", autorest.String(clientRequestID)))
	}
	if returnClientRequestID != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("return-client-request-id", autorest.String(returnClientRequestID)))
	}
	if ocpDate != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("ocp-date", autorest.String(ocpDate)))
	}
	return preparer.Prepare(&http.Request{})
}

// ListFromComputeNodeSender sends the ListFromComputeNode request. The method will close the
// http.Response Body if it receives an error.
func (client FileClient) ListFromComputeNodeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// ListFromComputeNodeResponder handles the response to the ListFromComputeNode request. The method always
// closes the http.Response Body.
func (client FileClient) ListFromComputeNodeResponder(resp *http.Response) (result NodeFileListResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListFromComputeNodeNextResults retrieves the next set of results, if any.
func (client FileClient) ListFromComputeNodeNextResults(lastResults NodeFileListResult) (result NodeFileListResult, err error) {
	req, err := lastResults.NodeFileListResultPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "batchservice.FileClient", "ListFromComputeNode", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.ListFromComputeNodeSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "batchservice.FileClient", "ListFromComputeNode", resp, "Failure sending next results request")
	}

	result, err = client.ListFromComputeNodeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "batchservice.FileClient", "ListFromComputeNode", resp, "Failure responding to next results request")
	}

	return
}

// ListFromComputeNodeComplete gets all elements from the list without paging.
func (client FileClient) ListFromComputeNodeComplete(poolID string, nodeID string, filter string, recursive *bool, maxResults *int32, timeout *int32, clientRequestID string, returnClientRequestID *bool, ocpDate *date.TimeRFC1123, cancel <-chan struct{}) (<-chan NodeFile, <-chan error) {
	resultChan := make(chan NodeFile)
	errChan := make(chan error, 1)
	go func() {
		defer func() {
			close(resultChan)
			close(errChan)
		}()
		list, err := client.ListFromComputeNode(poolID, nodeID, filter, recursive, maxResults, timeout, clientRequestID, returnClientRequestID, ocpDate)
		if err != nil {
			errChan <- err
			return
		}
		if list.Value != nil {
			for _, item := range *list.Value {
				select {
				case <-cancel:
					return
				case resultChan <- item:
					// Intentionally left blank
				}
			}
		}
		for list.OdataNextLink != nil {
			list, err = client.ListFromComputeNodeNextResults(list)
			if err != nil {
				errChan <- err
				return
			}
			if list.Value != nil {
				for _, item := range *list.Value {
					select {
					case <-cancel:
						return
					case resultChan <- item:
						// Intentionally left blank
					}
				}
			}
		}
	}()
	return resultChan, errChan
}

// ListFromTask lists the files in a task's directory on its compute node.
//
// jobID is the id of the job that contains the task. taskID is the id of the
// task whose files you want to list. filter is sets an OData $filter clause.
// recursive is sets whether to list children of a directory. maxResults is
// sets the maximum number of items to return in the response. timeout is sets
// the maximum time that the server can spend processing the request, in
// seconds. The default is 30 seconds. clientRequestID is caller generated
// request identity, in the form of a GUID with no decoration such as curly
// braces e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. returnClientRequestID is
// specifies if the server should return the client-request-id identifier in
// the response. ocpDate is the time the request was issued. If not specified,
// this header will be automatically populated with the current system clock
// time.
func (client FileClient) ListFromTask(jobID string, taskID string, filter string, recursive *bool, maxResults *int32, timeout *int32, clientRequestID string, returnClientRequestID *bool, ocpDate *date.TimeRFC1123) (result NodeFileListResult, err error) {
	req, err := client.ListFromTaskPreparer(jobID, taskID, filter, recursive, maxResults, timeout, clientRequestID, returnClientRequestID, ocpDate)
	if err != nil {
		err = autorest.NewErrorWithError(err, "batchservice.FileClient", "ListFromTask", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListFromTaskSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "batchservice.FileClient", "ListFromTask", resp, "Failure sending request")
		return
	}

	result, err = client.ListFromTaskResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "batchservice.FileClient", "ListFromTask", resp, "Failure responding to request")
	}

	return
}

// ListFromTaskPreparer prepares the ListFromTask request.
func (client FileClient) ListFromTaskPreparer(jobID string, taskID string, filter string, recursive *bool, maxResults *int32, timeout *int32, clientRequestID string, returnClientRequestID *bool, ocpDate *date.TimeRFC1123) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"jobId":  autorest.Encode("path", jobID),
		"taskId": autorest.Encode("path", taskID),
	}

	const APIVersion = "2015-12-01.2.2"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = autorest.Encode("query", filter)
	}
	if recursive != nil {
		queryParameters["recursive"] = autorest.Encode("query", *recursive)
	}
	if maxResults != nil {
		queryParameters["maxresults"] = autorest.Encode("query", *maxResults)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/jobs/{jobId}/tasks/{taskId}/files", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if len(clientRequestID) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("client-request-id", autorest.String(clientRequestID)))
	}
	if returnClientRequestID != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("return-client-request-id", autorest.String(returnClientRequestID)))
	}
	if ocpDate != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("ocp-date", autorest.String(ocpDate)))
	}
	return preparer.Prepare(&http.Request{})
}

// ListFromTaskSender sends the ListFromTask request. The method will close the
// http.Response Body if it receives an error.
func (client FileClient) ListFromTaskSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// ListFromTaskResponder handles the response to the ListFromTask request. The method always
// closes the http.Response Body.
func (client FileClient) ListFromTaskResponder(resp *http.Response) (result NodeFileListResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListFromTaskNextResults retrieves the next set of results, if any.
func (client FileClient) ListFromTaskNextResults(lastResults NodeFileListResult) (result NodeFileListResult, err error) {
	req, err := lastResults.NodeFileListResultPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "batchservice.FileClient", "ListFromTask", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.ListFromTaskSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "batchservice.FileClient", "ListFromTask", resp, "Failure sending next results request")
	}

	result, err = client.ListFromTaskResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "batchservice.FileClient", "ListFromTask", resp, "Failure responding to next results request")
	}

	return
}

// ListFromTaskComplete gets all elements from the list without paging.
func (client FileClient) ListFromTaskComplete(jobID string, taskID string, filter string, recursive *bool, maxResults *int32, timeout *int32, clientRequestID string, returnClientRequestID *bool, ocpDate *date.TimeRFC1123, cancel <-chan struct{}) (<-chan NodeFile, <-chan error) {
	resultChan := make(chan NodeFile)
	errChan := make(chan error, 1)
	go func() {
		defer func() {
			close(resultChan)
			close(errChan)
		}()
		list, err := client.ListFromTask(jobID, taskID, filter, recursive, maxResults, timeout, clientRequestID, returnClientRequestID, ocpDate)
		if err != nil {
			errChan <- err
			return
		}
		if list.Value != nil {
			for _, item := range *list.Value {
				select {
				case <-cancel:
					return
				case resultChan <- item:
					// Intentionally left blank
				}
			}
		}
		for list.OdataNextLink != nil {
			list, err = client.ListFromTaskNextResults(list)
			if err != nil {
				errChan <- err
				return
			}
			if list.Value != nil {
				for _, item := range *list.Value {
					select {
					case <-cancel:
						return
					case resultChan <- item:
						// Intentionally left blank
					}
				}
			}
		}
	}()
	return resultChan, errChan
}
